/*
 * can_by_ry.c
 *
 *  Created on: Feb 26, 2025
 *      Author: maday
 */

#include"main.h"
#include"can_by_ry.h"
/* CAN Master Control Register bits */
#define MCR_DBF      ((uint32_t)0x00010000) /* software master reset */
/* CAN Mailbox Transmit Request */
#define TMIDxR_TXRQ  ((uint32_t)0x00000001) /* Transmit mailbox request */
/* CAN Filter Master Register bits */
#define FMR_FINIT    ((uint32_t)0x00000001) /* Filter init mode */

/* Time out for INAK bit */
#define INAK_TIMEOUT        ((uint32_t)0x0000FFFF)
/* Time out for SLAK bit */
#define SLAK_TIMEOUT        ((uint32_t)0x0000FFFF)
/* Flags in TSR register */
#define CAN_FLAGS_TSR              ((uint32_t)0x08000000)
/* Flags in RF1R register */
#define CAN_FLAGS_RF1R             ((uint32_t)0x04000000)
/* Flags in RF0R register */
#define CAN_FLAGS_RF0R             ((uint32_t)0x02000000)
/* Flags in MSR register */
#define CAN_FLAGS_MSR              ((uint32_t)0x01000000)
/* Flags in ESR register */
#define CAN_FLAGS_ESR              ((uint32_t)0x00F00000)
/* Mailboxes definition */
#define CAN_TXMAILBOX_0                   ((uint8_t)0x00)
#define CAN_TXMAILBOX_1                   ((uint8_t)0x01)
#define CAN_TXMAILBOX_2                   ((uint8_t)0x02)
#define CAN_MODE_MASK              ((uint32_t) 0x00000003)
static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);



uint8_t CAN_Init()
{
	  uint8_t InitStatus = CAN_InitStatus_Failed;
	  uint32_t wait_ack = 0x00000000;
	  /* Exit from sleep mode */
	  CAN1->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
	  /* Request initialisation */
	  CAN1->MCR |= CAN_MCR_INRQ ;
	  /* Wait the acknowledge */
	  while (((CAN1->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
	  {
	    wait_ack++;
	  }
	  /* Check acknowledge */
	    if ((CAN1->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
	    {
	      InitStatus = CAN_InitStatus_Failed;
	    }
	    else
	    {
	      /* Set the time triggered communication mode */
	        CAN1->MCR &= ~(uint32_t)CAN_MCR_TTCM;
//	      if (CAN_InitStruct->CAN_TTCM == ENABLE)
//	      {
//	        CAN1->MCR |= CAN_MCR_TTCM;
//	      }
//	      else
//	      {
//	        CAN1->MCR &= ~(uint32_t)CAN_MCR_TTCM;
//	      }

	      /* Set the automatic bus-off management */
	        CAN1->MCR &= ~(uint32_t)CAN_MCR_ABOM;
//	      if (CAN_InitStruct->CAN_ABOM == ENABLE)
//	      {
//	        CAN1->MCR |= CAN_MCR_ABOM;
//	      }
//	      else
//	      {
//	        CAN1->MCR &= ~(uint32_t)CAN_MCR_ABOM;
//	      }

	      /* Set the automatic wake-up mode */
	        CAN1->MCR &= ~(uint32_t)CAN_MCR_AWUM;
//	      if (CAN_InitStruct->CAN_AWUM == ENABLE)
//	      {
//	        CAN1->MCR |= CAN_MCR_AWUM;
//	      }
//	      else
//	      {
//	        CAN1->MCR &= ~(uint32_t)CAN_MCR_AWUM;
//	      }

	      /* Set the no automatic retransmission */
	        CAN1->MCR &= ~(uint32_t)CAN_MCR_NART;
//	      if (CAN_InitStruct->CAN_NART == ENABLE)
//	      {
//	        CAN1->MCR |= CAN_MCR_NART;
//	      }
//	      else
//	      {
//	        CAN1->MCR &= ~(uint32_t)CAN_MCR_NART;
//	      }

	      /* Set the receive FIFO locked mode */
		  CAN1->MCR &= ~(uint32_t)CAN_MCR_RFLM;
//	      if (CAN_InitStruct->CAN_RFLM == ENABLE)
//	      {
//	        CAN1->MCR |= CAN_MCR_RFLM;
//	      }
//	      else
//	      {
//	        CAN1->MCR &= ~(uint32_t)CAN_MCR_RFLM;
//	      }

	      /* Set the transmit FIFO priority */
	        CAN1->MCR &= ~(uint32_t)CAN_MCR_TXFP;
//	      if (CAN_InitStruct->CAN_TXFP == ENABLE)
//	      {
//	        CAN1->MCR |= CAN_MCR_TXFP;
//	      }
//	      else
//	      {
//	        CAN1->MCR &= ~(uint32_t)CAN_MCR_TXFP;
//	      }

	      /* Set the bit timing register */
	      CAN1->BTR = (uint32_t)((uint32_t)CAN1->CAN_Mode << 30) |
	                  ((uint32_t)CAN1->IS_CAN_SJW(1) << 24) |
	                  ((uint32_t)CAN1->CAN_BS1 << 16) |
	                  ((uint32_t)CAN1->CAN_BS2 << 20) |
	                 ((uint32_t)CAN1->CAN_Prescaler - 1);

	      /* Request leave initialisation */
	      CAN1->MCR &= ~(uint32_t)CAN_MCR_INRQ;

	     /* Wait the acknowledge */
	     wait_ack = 0;

	     while (((CAN1->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
	     {
	       wait_ack++;
	     }

	      /* ...and check acknowledged */
	      if ((CAN1->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
	      {
	        InitStatus = CAN_InitStatus_Failed;
	      }
	      else
	      {
	        InitStatus = CAN_InitStatus_Success ;
	      }
	    }

	    /* At this step, return the status of initialization */
	    return InitStatus;
}



